#!/usr/bin/env bash
# shellcheck disable=SC1090,SC1091

case $- in
  *i*) ;;
  *) return;;
esac

if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
  . /etc/bash_completion
fi

HISTFILESIZE=10000
HISTCONTROL=ignoreboth

# Will for example suggest --allow-empty when doing completion for git commit
export GIT_COMPLETION_SHOW_ALL=1
export GIT_PAGER="less -FX"

export EDITOR="vim"

# Force loading of git completion function
if ! declare -f __git_complete > /dev/null; then
  bash_completion=$(pkg-config --variable=completionsdir bash-completion 2>/dev/null) ||
    bash_completion='/usr/share/bash-completion/completions'
  test -f "${bash_completion}/git" && . "${bash_completion}/git"
fi

alias open='xdg-open "$@" 2> /dev/null'
alias b='bundle'
alias grep="grep --color=auto"
alias ls="ls --color=auto"
alias xx="atool -x"
alias r="rails"

# Set up git aliases and auto completion (if necessary)
if declare -f __git_complete > /dev/null; then
  alias g="git"
  __git_complete g __git_main

  alias ga="git add"
  __git_complete ga _git_add

  alias gd="git diff"
  __git_complete gd _git_diff

  alias gst="git status"
  alias gc="git commit -v"
  alias gc!="git commit -v --amend"
  alias gca="git commit -v -a"
  alias gca!="git commit -v -a --amend"
fi

# Shows pwd in terminal title
function my_prompt_command() {
  echo -en "\033]0;$(dirs)\a"
}
PROMPT_COMMAND=my_prompt_command
PROMPT_COMMAND="history -a;$PROMPT_COMMAND"

PS1='\e[33m[\w]\e[0m\n-> $ '

# Turns off terminal suspend feature (<C-s> which freezes everything)
stty -ixon

[ -d $HOME/bin ] && export PATH="$HOME/bin:$PATH"
[ -d $HOME/.local/bin ] && export PATH="$HOME/.local/bin:$PATH"
[ -f ~/.dircolors ] && eval "$(dircolors ~/.dircolors)"

command -v direnv > /dev/null && eval "$(direnv hook bash)"

command -v highlight > /dev/null && export LESSOPEN="| highlight %s --out-format ansi --force --no-trailing-nl"
export LESS=" -R"

if [ -d ~/.bashrc.d ]; then
  for rc in ~/.bashrc.d/*; do
    if [ -f "$rc" ]; then
      . "$rc"
    fi
  done
fi

# TODO Maybe move this to bashrc.d
alias n="npm run-script"
_completion_loader npm
function alias_completion::n() {
  let COMP_CWORD+=1
  args=( "run-script" )
  COMP_WORDS=( npm ${args[@]} ${COMP_WORDS[@]:1} )
  _npm_completion
  }

complete -o default -F alias_completion::n n

# Source: https://stackoverflow.com/a/1793178
#
# wrap_alias takes three arguments:
# $1: The name of the alias
# $2: The command used in the alias
# $3: The arguments in the alias all in one string
# Generate a wrapper completion function (completer) for an alias
# based on the command and the given arguments, if there is a
# completer for the command, and set the wrapper as the completer for
# the alias.
function wrap_alias() {
  [[ "$#" == 3 ]] || return 1

  local alias_name="$1"
  local aliased_command="$2"
  local alias_arguments="$3"
  local num_alias_arguments=$(echo "$alias_arguments" | wc -w)

  # The completion currently being used for the aliased command.
  local completion=$(complete -p $aliased_command 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F
  # in the current completion. This check will also catch commands
  # with no completer for which $completion will be empty.
  echo $completion | grep -q -- -F || return 0

  local namespace=alias_completion::

  # Extract the name of the completion function from a string that
  # looks like: something -F function_name something
  # First strip the beginning of the string up to the function name by
  # removing "* -F " from the front.
  local completion_function=${completion##* -F }
  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function
  # generated by this function. This can happen when the user runs
  # this twice for an alias like ls='ls --color=auto' or alias l='ls'
  # and alias ls='l foo'
  [[ "${completion_function#$namespace}" != $completion_function ]] && return 0

  local wrapper_name="${namespace}${alias_name}"

  echo "
function ${wrapper_name}() {
  let COMP_CWORD+=$num_alias_arguments
  args=( \"${alias_arguments}\" )
  COMP_WORDS=( $aliased_command \${args[@]} \${COMP_WORDS[@]:1} )
  $completion_function
  }
"

  # To create the new completion we use the old one with two
  # replacements:
  # 1) Replace the function with the wrapper.
  local new_completion=${completion/-F * /-F $wrapper_name }
  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} $alias_name"

  echo "$new_completion"
}

# Example: wrap_alias n npm 'run-script'
export -f wrap_alias
